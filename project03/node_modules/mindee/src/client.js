"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Client_instances, _Client_buildEndpoint, _Client_initializeOTSEndpoint, _Client_cleanAccountName, _Client_getEndpoint;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const input_1 = require("./input");
const http_1 = require("./http");
const common_1 = require("./parsing/common");
const handler_1 = require("./errors/handler");
const logger_1 = require("./logger");
const inference_1 = require("./parsing/common/inference");
const product_1 = require("./product");
/**
 * Mindee Client class that centralizes most basic operations.
 *
 * @category Client
 */
class Client {
    /**
     * @param options options for the initialization of a client.
     */
    constructor({ apiKey, throwOnError, debug } = {
        apiKey: "",
        throwOnError: true,
        debug: false,
    }) {
        _Client_instances.add(this);
        this.apiKey = apiKey ? apiKey : "";
        handler_1.errorHandler.throwOnError = throwOnError ?? true;
        logger_1.logger.level =
            debug ?? process.env.MINDEE_DEBUG
                ? logger_1.LOG_LEVELS["debug"]
                : logger_1.LOG_LEVELS["warn"];
        logger_1.logger.debug("Client initialized");
    }
    /**
     * Send a document to a synchronous endpoint and parse the predictions.
     *
     * @param productClass product class to use for calling the API and parsing the response.
     * @param inputSource document to parse.
     * @param params parameters relating to prediction options.
     *
     * @typeParam T an extension of an `Inference`. Can be omitted as it will be inferred from the `productClass`.
     * @category Synchronous
     * @returns a `Promise` containing parsing results.
     */
    async parse(productClass, inputSource, params = {
        endpoint: undefined,
        allWords: undefined,
        cropper: undefined,
        pageOptions: undefined,
    }) {
        const endpoint = params?.endpoint ?? __classPrivateFieldGet(this, _Client_instances, "m", _Client_initializeOTSEndpoint).call(this, productClass);
        if (inputSource === undefined) {
            throw new Error("The 'parse' function requires an input document.");
        }
        const rawPrediction = await endpoint.predict({
            inputDoc: inputSource,
            includeWords: this.getBooleanParam(params.allWords),
            pageOptions: params.pageOptions,
            cropper: this.getBooleanParam(params.cropper),
        });
        return new common_1.PredictResponse(productClass, rawPrediction.data);
    }
    /**
     * Send the document to an asynchronous endpoint and return its ID in the queue.
     * @param productClass product class to use for calling  the API and parsing the response.
     * @param params parameters relating to prediction options.
     * @category Asynchronous
     *
     * @returns a `Promise` containing the job (queue) corresponding to a document.
     */
    async enqueue(productClass, inputSource, params = {}) {
        const endpoint = params?.endpoint ?? __classPrivateFieldGet(this, _Client_instances, "m", _Client_initializeOTSEndpoint).call(this, productClass);
        if (inputSource === undefined) {
            throw new Error("The 'parse' function requires an input document.");
        }
        const rawResponse = await endpoint.predictAsync({
            inputDoc: inputSource,
            includeWords: this.getBooleanParam(params.allWords),
            pageOptions: params?.pageOptions,
            cropper: this.getBooleanParam(params.cropper),
        });
        return new common_1.AsyncPredictResponse(productClass, rawResponse.data);
    }
    /**
     * Polls a queue and returns its status as well as the prediction results if the parsing is done.
     *
     * @param productClass product class to use for calling  the API and parsing the response.
     * @param queueId id of the queue to poll.
     * @param params parameters relating to prediction options.
     * @typeParam T an extension of an `Inference`. Can be omitted as it will be inferred from the `productClass`.
     * @category Asynchronous
     *
     * @returns a `Promise` containing a `Job`, which also contains a `Document` if the
     * parsing is complete.
     */
    async parseQueued(productClass, queueId, params = {}) {
        const endpoint = params?.endpoint ?? __classPrivateFieldGet(this, _Client_instances, "m", _Client_initializeOTSEndpoint).call(this, productClass);
        const docResponse = await endpoint.getQueuedDocument(queueId);
        return new common_1.AsyncPredictResponse(productClass, docResponse.data);
    }
    /**
     * Forces boolean coercion on truthy/falsy parameters.
     * @param param input parameter to check.
     * @returns a strict boolean value.
     */
    getBooleanParam(param) {
        return param !== undefined ? param : false;
    }
    /**
     * Creates a custom endpoint with the given values. Raises an error if the endpoint is invalid.
     * @param productClass product class to use for calling the API and parsing the response.
     * @param endpointName Name of the custom Endpoint.
     * @param accountName Name of the account tied to the Endpoint.
     * @param version Version of the custom Endpoint.
     * @typeParam T an extension of an `Inference`. Can be omitted as it will be inferred from the `productClass`.
     *
     * @returns a new endpoint
     */
    createEndpoint(endpointName, accountName, endpointVersion) {
        const cleanAccountName = __classPrivateFieldGet(this, _Client_instances, "m", _Client_cleanAccountName).call(this, product_1.CustomV1, accountName);
        if (!endpointName || endpointName.length === 0) {
            throw new Error("Missing parameter 'endpointName' for custom build!");
        }
        let cleanEndpointVersion;
        if (!endpointVersion || endpointVersion.length === 0) {
            logger_1.logger.debug("Warning: No version provided for a custom build, will attempt to poll version 1 by default.");
            cleanEndpointVersion = "1";
        }
        else {
            cleanEndpointVersion = endpointVersion;
        }
        return __classPrivateFieldGet(this, _Client_instances, "m", _Client_buildEndpoint).call(this, endpointName, cleanAccountName, cleanEndpointVersion);
    }
    /**
     * Load an input document from a local path.
     * @param inputPath
     */
    docFromPath(inputPath) {
        return new input_1.PathInput({
            inputPath: inputPath,
        });
    }
    /**
     * Load an input document from a base64 encoded string.
     * @param inputString input content, as a string.
     * @param filename file name.
     */
    docFromBase64(inputString, filename) {
        return new input_1.Base64Input({
            inputString: inputString,
            filename: filename,
        });
    }
    /**
     * Load an input document from a `stream.Readable` object.
     * @param inputStream input content, as a readable stream.
     * @param filename file name.
     */
    docFromStream(inputStream, filename) {
        return new input_1.StreamInput({
            inputStream: inputStream,
            filename: filename,
        });
    }
    /**
     * Load an input document from a bytes string.
     * @param inputBytes input content, as readable bytes.
     * @param filename file name.
     */
    docFromBytes(inputBytes, filename) {
        return new input_1.BytesInput({
            inputBytes: inputBytes,
            filename: filename,
        });
    }
    /**
     * Load an input document from a URL.
     * @param url input url. Must be HTTPS.
     */
    docFromUrl(url) {
        return new input_1.UrlInput({
            url: url,
        });
    }
    /**
     * Load an input document from a Buffer.
     * @param buffer input content, as a buffer.
     * @param filename file name.
     */
    docFromBuffer(buffer, filename) {
        return new input_1.BufferInput({
            buffer: buffer,
            filename: filename,
        });
    }
}
exports.Client = Client;
_Client_instances = new WeakSet(), _Client_buildEndpoint = function _Client_buildEndpoint(endpointName, accountName, endpointVersion) {
    const apiSettings = new http_1.MindeeApi({
        apiKey: this.apiKey,
        urlName: endpointName,
        version: endpointVersion,
        owner: accountName,
    });
    return new http_1.Endpoint(endpointName, accountName, endpointVersion, apiSettings);
}, _Client_initializeOTSEndpoint = function _Client_initializeOTSEndpoint(productClass) {
    if (productClass.name === "CustomV1") {
        throw new Error("Incorrect parameters for Custom build.");
    }
    const [endpointName, endpointVersion] = __classPrivateFieldGet(this, _Client_instances, "m", _Client_getEndpoint).call(this, productClass);
    return __classPrivateFieldGet(this, _Client_instances, "m", _Client_buildEndpoint).call(this, endpointName, http_1.STANDARD_API_OWNER, endpointVersion);
}, _Client_cleanAccountName = function _Client_cleanAccountName(productClass, accountName) {
    if (productClass.name === "CustomV1") {
        if (!accountName || accountName.length === 0) {
            logger_1.logger.debug(`Warning: no account name provided for custom build, ${http_1.STANDARD_API_OWNER} will be used by default`);
            return http_1.STANDARD_API_OWNER;
        }
        return accountName;
    }
    return http_1.STANDARD_API_OWNER;
}, _Client_getEndpoint = function _Client_getEndpoint(productClass) {
    const [endpointName, endpointVersion] = inference_1.InferenceFactory.getEndpoint(productClass);
    return [endpointName, endpointVersion];
};
