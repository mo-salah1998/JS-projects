"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InferenceFactory = exports.Inference = void 0;
/**
 *
 * @typeParam DocT an extension of a `Prediction`. Is generic by default to
 * allow for easier optional `PageT` generic typing.
 * @typeParam PageT an extension of a `DocT` (`Prediction`). Should only be set
 * if a document's pages have specific implementation.
 */
class Inference {
    constructor(rawPrediction) {
        /** Wrapper for a document's pages prediction. */
        this.pages = [];
        /** Extraneous fields relating to specific tools for some APIs. */
        this.extras = [];
        this.isRotationApplied = rawPrediction?.is_rotation_applied ?? undefined;
        this.product = rawPrediction?.product;
    }
    /**
     * Default string representation.
     */
    toString() {
        return `Inference
#########
:Product: ${this.product.name} v${this.product.version}
:Rotation applied: ${this.isRotationApplied ? "Yes" : "No"}

Prediction
==========
${this.prediction.toString() || ""}

Page Predictions
================

${this.pages.map((e) => e.toString() || "").join("\n")}`;
    }
    /**
     * Takes in an input string and replaces line breaks with `\n`.
     * @param outStr string to cleanup
     * @returns cleaned out string
     */
    static cleanOutString(outStr) {
        const lines = / \n/gm;
        return outStr.replace(lines, "\n");
    }
}
exports.Inference = Inference;
/**
 * Factory to allow for static-like property access syntax in TypeScript.
 * Used to retrieve endpoint data for standard products.
 */
class InferenceFactory {
    /**
     * Builds a blank product of the given type & sends back the endpointName & endpointVersion parameters of OTS classes.
     * Note: this is needed to avoid passing anything other than the class of the object to the parse()/enqueue() call.
     * @param inferenceClass Class of the product we are using
     * @returns {Inference} An empty instance of a given product.
     */
    static getEndpoint(inferenceClass) {
        if (inferenceClass.name === "CustomV1") {
            throw new Error("Cannot process custom endpoint as OTS API endpoints. Please provide an endpoint name & version manually.");
        }
        const emptyProduct = new inferenceClass({
            prediction: {},
            pages: [],
        });
        if (!emptyProduct.endpointName ||
            !emptyProduct.endpointVersion ||
            emptyProduct.endpointName.length === 0 ||
            emptyProduct.endpointVersion.length === 0) {
            throw new Error(`Error during endpoint verification, no endpoint found for product ${inferenceClass.name}.`);
        }
        return [emptyProduct.endpointName, emptyProduct.endpointVersion];
    }
}
exports.InferenceFactory = InferenceFactory;
