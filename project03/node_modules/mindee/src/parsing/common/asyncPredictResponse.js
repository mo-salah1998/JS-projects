"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncPredictResponse = exports.Job = void 0;
const apiResponse_1 = require("./apiResponse");
const document_1 = require("./document");
/** Wrapper for asynchronous request queues. Holds information regarding a job (queue).
 *
 * @category API Response
 * @category Asynchronous
*/
class Job {
    constructor(jsonResponse) {
        this.issuedAt = this.datetimeWithTimezone(jsonResponse["issued_at"]);
        if (jsonResponse["available_at"] !== undefined &&
            jsonResponse["available_at"] !== null) {
            this.availableAt = this.datetimeWithTimezone(jsonResponse["available_at"]);
        }
        this.id = jsonResponse["id"];
        this.status = jsonResponse["status"];
        if (this.availableAt !== undefined) {
            this.milliSecsTaken =
                this.availableAt.getTime() - this.issuedAt.getTime();
        }
    }
    // Hideous thing to make sure dates sent back by the server are parsed correctly in UTC.
    datetimeWithTimezone(date) {
        if (date.search(/\+[0-9]{2}:[0-9]{2}$/) === -1) {
            date += "+00:00";
        }
        return new Date(date);
    }
}
exports.Job = Job;
/** Wrapper for asynchronous jobs and parsing results.
 *
 * @category API Response
 * @category Asynchronous
*/
class AsyncPredictResponse extends apiResponse_1.ApiResponse {
    /**
     *
     * @param inferenceClass constructor signature for an inference.
     * @param httpResponse raw http response.
     */
    constructor(inferenceClass, httpResponse) {
        super(httpResponse);
        this.job = new Job(httpResponse["job"]);
        this.document =
            httpResponse["document"] !== undefined
                ? new document_1.Document(inferenceClass, httpResponse["document"])
                : undefined;
    }
}
exports.AsyncPredictResponse = AsyncPredictResponse;
